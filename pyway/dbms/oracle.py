import oracledb
import os
from typing import List

from pyway.migration import Migration
from pyway.configfile import ConfigFile


CREATE_VERSION_MIGRATIONS = "create table %s ("\
    "installed_rank NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,"\
    "version varchar2(20) NOT NULL,"\
    "extension varchar2(20) NOT NULL,"\
    "name varchar2(125) NOT NULL,"\
    "checksum varchar2(25) NOT NULL,"\
    "apply_timestamp timestamp DEFAULT CURRENT_TIMESTAMP"\
    ")"
SELECT_FIELDS = ("version", "extension", "name", "checksum", "apply_timestamp")
ORDER_BY_FIELD_ASC = "installed_rank"
ORDER_BY_FIELD_DESC = "installed_rank desc"
INSERT_VERSION_MIGRATE = "insert into %s (version, extension, name, checksum) values ('%s', '%s', '%s', '%s')"
UPDATE_CHECKSUM = "update %s set checksum='%s' where version='%s'"


class Oracle():

    def __init__(self, config: ConfigFile) -> None:
        self.config = config
        self.version_table = config.database_table
        
        self._init_oracle_client()
        
        self.create_version_table_if_not_exists()
    
    def _init_oracle_client(self) -> None:
        oracle_lib_dir = getattr(self.config, 'oracle_client_lib_dir', None) or os.getenv('ORACLE_CLIENT_LIB_DIR')
        
        self._configure_wallet()
        
        if oracle_lib_dir and os.path.exists(oracle_lib_dir):
            try:
                oracledb.init_oracle_client(lib_dir=oracle_lib_dir)
                print(f"Oracle Client initialized from: {oracle_lib_dir}")
            except Exception as e:
                print(f"Warning: Could not initialize Oracle Client: {e}")
        else:
            try:
                oracledb.init_oracle_client()
                print("Oracle Client initialized in Thin mode")
            except Exception as e:
                print(f"Info: Using Oracle Thin mode (no local client): {e}")
    
    def _configure_wallet(self) -> None:
        wallet_location = getattr(self.config, 'oracle_wallet_location', None)
        
        if wallet_location and os.path.exists(wallet_location):
            # Configure TNS_ADMIN for wallet
            os.environ['TNS_ADMIN'] = wallet_location
            print(f"Oracle Wallet configured from: {wallet_location}")
        elif os.getenv('TNS_ADMIN'):
            print(f"Using Oracle Wallet from TNS_ADMIN: {os.getenv('TNS_ADMIN')}")

    def connect(self) -> oracledb.Connection:
        connection_params = {}

        # Determine DSN flexibly
        connection_params['dsn'] = self._build_dsn()

        # Configure authentication based on Oracle Wallet or traditional credentials
        if self._is_wallet_authentication():
            # Oracle Wallet authentication - no username/password required
            print("Using Oracle Wallet authentication")
        else:
            # Traditional username/password authentication
            if not self.config.database_username:
                raise ValueError("database_username is required when not using Oracle Wallet")
            
            connection_params['user'] = self.config.database_username
            
            if self.config.database_password:
                connection_params['password'] = self.config.database_password

        return oracledb.connect(**connection_params)
    
    def _is_wallet_authentication(self) -> bool:
        # Option 1: Explicit configuration
        if hasattr(self.config, 'oracle_use_wallet') and self.config.oracle_use_wallet:
            return True
            
        # Option 2: Wallet location configured without username
        wallet_location = getattr(self.config, 'oracle_wallet_location', None) or os.getenv('TNS_ADMIN')
        if wallet_location and not getattr(self.config, 'database_username', None):
            return True
            
        # Option 3: TNS_ADMIN configured without username
        if os.getenv('TNS_ADMIN') and not getattr(self.config, 'database_username', None):
            return True
            
        return False
    
    def _build_dsn(self) -> str:
        # Case 1: If database_name appears to be a complete DSN, use it directly
        if (self.config.database_name and 
            ('=' in self.config.database_name or '(' in self.config.database_name)):
            return self.config.database_name
        
        # Case 2: If host is configured, build Easy Connect
        if (hasattr(self.config, 'database_host') and 
            self.config.database_host and 
            self.config.database_host.strip()):
            
            if (hasattr(self.config, 'database_port') and 
                self.config.database_port and 
                str(self.config.database_port).strip()):
                # Host:Port/Service
                return f"{self.config.database_host}:{self.config.database_port}/{self.config.database_name}"
            else:
                # Host/Service (default port)
                return f"{self.config.database_host}:1521/{self.config.database_name}"
        
        # Case 3: database_name only - assume TNS Names
        return self.config.database_name

    def create_version_table_if_not_exists(self) -> None:
        cnx = self.connect()
        cursor = cnx.cursor()
        try:
            cursor.execute(f"SELECT 1 FROM {self.version_table} WHERE ROWNUM = 1")
        except oracledb.DatabaseError:
            cursor.execute(CREATE_VERSION_MIGRATIONS % self.version_table)
            cnx.commit()
        finally:
            cursor.close()
            cnx.close()

    def execute(self, script: str) -> None:
        cnx = self.connect()
        cursor = cnx.cursor()
        cursor.execute(script)
        cnx.commit()
        cursor.close()
        cnx.close()

    def get_all_schema_migrations(self) -> List[Migration]:
        cnx = self.connect()
        cursor = cnx.cursor()
        cursor.execute(f"SELECT {','.join(SELECT_FIELDS)} FROM {self.version_table} ORDER BY {ORDER_BY_FIELD_ASC}")
        migrations = []
        for row in cursor.fetchall():
            migrations.append(Migration(row[0], row[1], row[2], row[3], row[4]))
        cursor.close()
        cnx.close()
        return migrations

    def get_schema_migration(self, version: str) -> Migration:
        cnx = self.connect()
        cursor = cnx.cursor()
        cursor.execute(
            f"SELECT {','.join(SELECT_FIELDS)} FROM {self.version_table} WHERE version=:version",
            {'version': version}
        )
        row = cursor.fetchone()
        if row is not None:
            migration = Migration(row[0], row[1], row[2], row[3], row[4])
        cursor.close()
        cnx.close()
        return migration

    def upgrade_version(self, migration: Migration) -> None:
        self.execute(INSERT_VERSION_MIGRATE % (self.version_table, migration.version,
                                               migration.extension, migration.name,
                                               migration.checksum))

    def update_checksum(self, migration: Migration) -> None:
        self.execute(UPDATE_CHECKSUM % (self.version_table, migration.checksum, migration.version))
